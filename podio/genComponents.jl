# Automatically generated by generate.jl from edm4hep.yaml (schema version 3)
schema_version = v"3"

"""
A generic 4 dimensional covariance matrix with values stored in lower triangular form
# Fields
- `values::SVector{10,Float32}`:  the covariance matrix values 
"""
struct CovMatrix4f <: POD
    values::SVector{10,Float32}      #  the covariance matrix values 
    CovMatrix4f(values=zero(SVector{10,Float32})) = new(values)
end

Base.convert(::Type{CovMatrix4f}, t::Tuple) = CovMatrix4f(t...)
Base.convert(::Type{CovMatrix4f}, v::@NamedTuple{values::SVector{10,Float32}}) = CovMatrix4f(v.values)

"""
Vector2f
# Fields
- `a::Float32`: 
- `b::Float32`: 
"""
struct Vector2f <: POD
    a::Float32                        
    b::Float32                        
    Vector2f(a=zero(Float32), b=zero(Float32)) = new(a, b)
end

Base.convert(::Type{Vector2f}, t::Tuple) = Vector2f(t...)
Base.convert(::Type{Vector2f}, v::@NamedTuple{a::Float32, b::Float32}) = Vector2f(v.a, v.b)

"""
Generic vector for storing classical 4D coordinates in memory. Four momentum helper functions are in edm4hep::utils
# Fields
- `x::Float32`: 
- `y::Float32`: 
- `z::Float32`: 
- `t::Float32`: 
"""
struct Vector4f <: POD
    x::Float32                        
    y::Float32                        
    z::Float32                        
    t::Float32                        
    Vector4f(x=zero(Float32), y=zero(Float32), z=zero(Float32), t=zero(Float32)) = new(x, y, z, t)
end

Base.convert(::Type{Vector4f}, t::Tuple) = Vector4f(t...)
Base.convert(::Type{Vector4f}, v::@NamedTuple{x::Float32, y::Float32, z::Float32, t::Float32}) = Vector4f(v.x, v.y, v.z, v.t)

"""
A generic 2 dimensional covariance matrix with values stored in lower triangular form
# Fields
- `values::SVector{3,Float32}`:  the covariance matrix values 
"""
struct CovMatrix2f <: POD
    values::SVector{3,Float32}       #  the covariance matrix values 
    CovMatrix2f(values=zero(SVector{3,Float32})) = new(values)
end

Base.convert(::Type{CovMatrix2f}, t::Tuple) = CovMatrix2f(t...)
Base.convert(::Type{CovMatrix2f}, v::@NamedTuple{values::SVector{3,Float32}}) = CovMatrix2f(v.values)

"""
Vector3f
# Fields
- `x::Float32`: 
- `y::Float32`: 
- `z::Float32`: 
"""
struct Vector3f <: POD
    x::Float32                        
    y::Float32                        
    z::Float32                        
    Vector3f(x=zero(Float32), y=zero(Float32), z=zero(Float32)) = new(x, y, z)
end

Base.convert(::Type{Vector3f}, t::Tuple) = Vector3f(t...)
Base.convert(::Type{Vector3f}, v::@NamedTuple{x::Float32, y::Float32, z::Float32}) = Vector3f(v.x, v.y, v.z)

"""
Quantity
# Fields
- `type::Int16`:  flag identifying how to interpret the quantity 
- `value::Float32`:  value of the quantity 
- `error::Float32`:  error on the value of the quantity 
"""
struct Quantity <: POD
    type::Int16                      #  flag identifying how to interpret the quantity 
    value::Float32                   #  value of the quantity 
    error::Float32                   #  error on the value of the quantity 
    Quantity(type=zero(Int16), value=zero(Float32), error=zero(Float32)) = new(type, value, error)
end

Base.convert(::Type{Quantity}, t::Tuple) = Quantity(t...)
Base.convert(::Type{Quantity}, v::@NamedTuple{type::Int16, value::Float32, error::Float32}) = Quantity(v.type, v.value, v.error)

"""
Vector3d
# Fields
- `x::Float64`: 
- `y::Float64`: 
- `z::Float64`: 
"""
struct Vector3d <: POD
    x::Float64                        
    y::Float64                        
    z::Float64                        
    Vector3d(x=zero(Float64), y=zero(Float64), z=zero(Float64)) = new(x, y, z)
end

Base.convert(::Type{Vector3d}, t::Tuple) = Vector3d(t...)
Base.convert(::Type{Vector3d}, v::@NamedTuple{x::Float64, y::Float64, z::Float64}) = Vector3d(v.x, v.y, v.z)

"""
A generic 3 dimensional covariance matrix with values stored in lower triangular form
# Fields
- `values::SVector{6,Float32}`:  the covariance matrix values 
"""
struct CovMatrix3f <: POD
    values::SVector{6,Float32}       #  the covariance matrix values 
    CovMatrix3f(values=zero(SVector{6,Float32})) = new(values)
end

Base.convert(::Type{CovMatrix3f}, t::Tuple) = CovMatrix3f(t...)
Base.convert(::Type{CovMatrix3f}, v::@NamedTuple{values::SVector{6,Float32}}) = CovMatrix3f(v.values)

"""
A generic 6 dimensional covariance matrix with values stored in lower triangular form
# Fields
- `values::SVector{21,Float32}`:  the covariance matrix values 
"""
struct CovMatrix6f <: POD
    values::SVector{21,Float32}      #  the covariance matrix values 
    CovMatrix6f(values=zero(SVector{21,Float32})) = new(values)
end

Base.convert(::Type{CovMatrix6f}, t::Tuple) = CovMatrix6f(t...)
Base.convert(::Type{CovMatrix6f}, v::@NamedTuple{values::SVector{21,Float32}}) = CovMatrix6f(v.values)

"""
Parametrized description of a particle track
# Fields
- `location::Int32`:  for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation 
- `D0::Float32`:  transverse impact parameter 
- `phi::Float32`:  azimuthal angle 
- `omega::Float32`:  is the signed curvature of the track [1/mm]
- `Z0::Float32`:  longitudinal impact parameter 
- `tanLambda::Float32`:  lambda is the dip angle of the track in r-z 
- `time::Float32`:  time of the track at this trackstate [ns]
- `referencePoint::Vector3f`:  Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter [mm]
- `covMatrix::CovMatrix6f`:  covariance matrix of the track parameters. 
"""
struct TrackState <: POD
    location::Int32                  #  for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation 
    D0::Float32                      #  transverse impact parameter 
    phi::Float32                     #  azimuthal angle 
    omega::Float32                   #  is the signed curvature of the track [1/mm]
    Z0::Float32                      #  longitudinal impact parameter 
    tanLambda::Float32               #  lambda is the dip angle of the track in r-z 
    time::Float32                    #  time of the track at this trackstate [ns]
    referencePoint::Vector3f         #  Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter [mm]
    covMatrix::CovMatrix6f           #  covariance matrix of the track parameters. 
    TrackState(location=zero(Int32), D0=zero(Float32), phi=zero(Float32), omega=zero(Float32), Z0=zero(Float32), tanLambda=zero(Float32), time=zero(Float32), referencePoint=zero(Vector3f), covMatrix=zero(CovMatrix6f)) = new(location, D0, phi, omega, Z0, tanLambda, time, referencePoint, covMatrix)
end

Base.convert(::Type{TrackState}, t::Tuple) = TrackState(t...)
Base.convert(::Type{TrackState}, v::@NamedTuple{location::Int32, D0::Float32, phi::Float32, omega::Float32, Z0::Float32, tanLambda::Float32, time::Float32, referencePoint::Vector3f, covMatrix::CovMatrix6f}) = TrackState(v.location, v.D0, v.phi, v.omega, v.Z0, v.tanLambda, v.time, v.referencePoint, v.covMatrix)

export CovMatrix4f, Vector2f, Vector4f, CovMatrix2f, Vector3f, Quantity, Vector3d, CovMatrix3f, CovMatrix6f, TrackState
