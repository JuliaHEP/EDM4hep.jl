# Automatically generated by generate.jl from edm4hep.yaml (schema version 6)
schema_version = v"6"

"""
A generic 4 dimensional covariance matrix with values stored in lower triangular form
# Fields
- `values::SVector{10,Float32}`:  the covariance matrix values
"""
struct edm4hep!CovMatrix4f <: POD
    values::SVector{10,Float32}      #  the covariance matrix values
    edm4hep!CovMatrix4f(values=zero(SVector{10,Float32})) = new(values)
end

Base.convert(::Type{edm4hep!CovMatrix4f}, t::Tuple) = edm4hep!CovMatrix4f(t...)
Base.convert(::Type{edm4hep!CovMatrix4f}, v::@NamedTuple{values::SVector{10,Float32}}) = edm4hep!CovMatrix4f(v.values)

"""
edm4hep!Vector2f
# Fields
- `a::Float32`: 
- `b::Float32`: 
"""
struct edm4hep!Vector2f <: POD
    a::Float32                       
    b::Float32                       
    edm4hep!Vector2f(a=zero(Float32), b=zero(Float32)) = new(a, b)
end

Base.convert(::Type{edm4hep!Vector2f}, t::Tuple) = edm4hep!Vector2f(t...)
Base.convert(::Type{edm4hep!Vector2f}, v::@NamedTuple{a::Float32, b::Float32}) = edm4hep!Vector2f(v.a, v.b)

"""
Generic vector for storing classical 4D coordinates in memory. Four momentum helper functions are in edm4hep::utils
# Fields
- `x::Float32`: 
- `y::Float32`: 
- `z::Float32`: 
- `t::Float32`: 
"""
struct edm4hep!Vector4f <: POD
    x::Float32                       
    y::Float32                       
    z::Float32                       
    t::Float32                       
    edm4hep!Vector4f(x=zero(Float32), y=zero(Float32), z=zero(Float32), t=zero(Float32)) = new(x, y, z, t)
end

Base.convert(::Type{edm4hep!Vector4f}, t::Tuple) = edm4hep!Vector4f(t...)
Base.convert(::Type{edm4hep!Vector4f}, v::@NamedTuple{x::Float32, y::Float32, z::Float32, t::Float32}) = edm4hep!Vector4f(v.x, v.y, v.z, v.t)

"""
A generic 2 dimensional covariance matrix with values stored in lower triangular form
# Fields
- `values::SVector{3,Float32}`:  the covariance matrix values
"""
struct edm4hep!CovMatrix2f <: POD
    values::SVector{3,Float32}       #  the covariance matrix values
    edm4hep!CovMatrix2f(values=zero(SVector{3,Float32})) = new(values)
end

Base.convert(::Type{edm4hep!CovMatrix2f}, t::Tuple) = edm4hep!CovMatrix2f(t...)
Base.convert(::Type{edm4hep!CovMatrix2f}, v::@NamedTuple{values::SVector{3,Float32}}) = edm4hep!CovMatrix2f(v.values)

"""
edm4hep!Vector3f
# Fields
- `x::Float32`: 
- `y::Float32`: 
- `z::Float32`: 
"""
struct edm4hep!Vector3f <: POD
    x::Float32                       
    y::Float32                       
    z::Float32                       
    edm4hep!Vector3f(x=zero(Float32), y=zero(Float32), z=zero(Float32)) = new(x, y, z)
end

Base.convert(::Type{edm4hep!Vector3f}, t::Tuple) = edm4hep!Vector3f(t...)
Base.convert(::Type{edm4hep!Vector3f}, v::@NamedTuple{x::Float32, y::Float32, z::Float32}) = edm4hep!Vector3f(v.x, v.y, v.z)

"""
edm4hep!Quantity
# Fields
- `type::Int32`:  flag identifying how to interpret the quantity
- `value::Float32`:  value of the quantity
- `error::Float32`:  error on the value of the quantity
"""
struct edm4hep!Quantity <: POD
    type::Int32                      #  flag identifying how to interpret the quantity
    value::Float32                   #  value of the quantity
    error::Float32                   #  error on the value of the quantity
    edm4hep!Quantity(type=zero(Int32), value=zero(Float32), error=zero(Float32)) = new(type, value, error)
end

Base.convert(::Type{edm4hep!Quantity}, t::Tuple) = edm4hep!Quantity(t...)
Base.convert(::Type{edm4hep!Quantity}, v::@NamedTuple{type::Int32, value::Float32, error::Float32}) = edm4hep!Quantity(v.type, v.value, v.error)

"""
edm4hep!Vector3d
# Fields
- `x::Float64`: 
- `y::Float64`: 
- `z::Float64`: 
"""
struct edm4hep!Vector3d <: POD
    x::Float64                       
    y::Float64                       
    z::Float64                       
    edm4hep!Vector3d(x=zero(Float64), y=zero(Float64), z=zero(Float64)) = new(x, y, z)
end

Base.convert(::Type{edm4hep!Vector3d}, t::Tuple) = edm4hep!Vector3d(t...)
Base.convert(::Type{edm4hep!Vector3d}, v::@NamedTuple{x::Float64, y::Float64, z::Float64}) = edm4hep!Vector3d(v.x, v.y, v.z)

"""
A generic 3 dimensional covariance matrix with values stored in lower triangular form
# Fields
- `values::SVector{6,Float32}`:  the covariance matrix values
"""
struct edm4hep!CovMatrix3f <: POD
    values::SVector{6,Float32}       #  the covariance matrix values
    edm4hep!CovMatrix3f(values=zero(SVector{6,Float32})) = new(values)
end

Base.convert(::Type{edm4hep!CovMatrix3f}, t::Tuple) = edm4hep!CovMatrix3f(t...)
Base.convert(::Type{edm4hep!CovMatrix3f}, v::@NamedTuple{values::SVector{6,Float32}}) = edm4hep!CovMatrix3f(v.values)

"""
A generic 6 dimensional covariance matrix with values stored in lower triangular form
# Fields
- `values::SVector{21,Float32}`:  the covariance matrix values
"""
struct edm4hep!CovMatrix6f <: POD
    values::SVector{21,Float32}      #  the covariance matrix values
    edm4hep!CovMatrix6f(values=zero(SVector{21,Float32})) = new(values)
end

Base.convert(::Type{edm4hep!CovMatrix6f}, t::Tuple) = edm4hep!CovMatrix6f(t...)
Base.convert(::Type{edm4hep!CovMatrix6f}, v::@NamedTuple{values::SVector{21,Float32}}) = edm4hep!CovMatrix6f(v.values)

"""
Parametrized description of a particle track
# Fields
- `location::Int32`:  for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation
- `D0::Float32`:  transverse impact parameter
- `phi::Float32`:  azimuthal angle of the track at this location (i.e. not phi0)
- `omega::Float32`:  is the signed curvature of the track
- `Z0::Float32`:  longitudinal impact parameter
- `tanLambda::Float32`:  lambda is the dip angle of the track in r-z
- `time::Float32`:  time of the track at this trackstate
- `referencePoint::edm4hep!Vector3f`:  Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter
- `covMatrix::edm4hep!CovMatrix6f`:  covariance matrix of the track parameters.
"""
struct edm4hep!TrackState <: POD
    location::Int32                  #  for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation
    D0::Float32                      #  transverse impact parameter
    phi::Float32                     #  azimuthal angle of the track at this location (i.e. not phi0)
    omega::Float32                   #  is the signed curvature of the track
    Z0::Float32                      #  longitudinal impact parameter
    tanLambda::Float32               #  lambda is the dip angle of the track in r-z
    time::Float32                    #  time of the track at this trackstate
    referencePoint::edm4hep!Vector3f #  Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter
    covMatrix::edm4hep!CovMatrix6f   #  covariance matrix of the track parameters.
    edm4hep!TrackState(location=zero(Int32), D0=zero(Float32), phi=zero(Float32), omega=zero(Float32), Z0=zero(Float32), tanLambda=zero(Float32), time=zero(Float32), referencePoint=zero(edm4hep!Vector3f), covMatrix=zero(edm4hep!CovMatrix6f)) = new(location, D0, phi, omega, Z0, tanLambda, time, referencePoint, covMatrix)
end

Base.convert(::Type{edm4hep!TrackState}, t::Tuple) = edm4hep!TrackState(t...)
Base.convert(::Type{edm4hep!TrackState}, v::@NamedTuple{location::Int32, D0::Float32, phi::Float32, omega::Float32, Z0::Float32, tanLambda::Float32, time::Float32, referencePoint::edm4hep!Vector3f, covMatrix::edm4hep!CovMatrix6f}) = edm4hep!TrackState(v.location, v.D0, v.phi, v.omega, v.Z0, v.tanLambda, v.time, v.referencePoint, v.covMatrix)


#---Aliases for easier access
const CovMatrix6f = edm4hep!CovMatrix6f
const CovMatrix3f = edm4hep!CovMatrix3f
const Vector3d = edm4hep!Vector3d
const Quantity = edm4hep!Quantity
const Vector3f = edm4hep!Vector3f
const CovMatrix2f = edm4hep!CovMatrix2f
const TrackState = edm4hep!TrackState
const Vector4f = edm4hep!Vector4f
const Vector2f = edm4hep!Vector2f
const CovMatrix4f = edm4hep!CovMatrix4f


#---Exports
export edm4hep!CovMatrix4f, edm4hep!Vector2f, edm4hep!Vector4f, edm4hep!CovMatrix2f, edm4hep!Vector3f, edm4hep!Quantity, edm4hep!Vector3d, edm4hep!CovMatrix3f, edm4hep!CovMatrix6f, edm4hep!TrackState, CovMatrix6f, CovMatrix3f, Vector3d, Quantity, Vector3f, CovMatrix2f, TrackState, Vector4f, Vector2f, CovMatrix4f
