# Automatically generated by generate.jl from edm4hep.yaml (schema version 830)
schema_version = v"830"

"""
edm4hep!Vector2f
# Fields
- `a::Float32`: 
- `b::Float32`: 
"""
struct edm4hep!Vector2f <: POD
    a::Float32                       
    b::Float32                       
    edm4hep!Vector2f(a=0, b=0) = new(a, b)
end

Base.convert(::Type{edm4hep!Vector2f}, t::Tuple) = edm4hep!Vector2f(t...)
Base.convert(::Type{edm4hep!Vector2f}, v::@NamedTuple{a::Float32, b::Float32}) = edm4hep!Vector2f(v.a, v.b)

"""
Generic vector for storing classical 4D coordinates in memory. Four momentum helper functions are in edm4hep::utils
# Fields
- `x::Float32`: 
- `y::Float32`: 
- `z::Float32`: 
- `t::Float32`: 
"""
struct edm4hep!Vector4f <: POD
    x::Float32                       
    y::Float32                       
    z::Float32                       
    t::Float32                       
    edm4hep!Vector4f(x=0, y=0, z=0, t=0) = new(x, y, z, t)
end

Base.convert(::Type{edm4hep!Vector4f}, t::Tuple) = edm4hep!Vector4f(t...)
Base.convert(::Type{edm4hep!Vector4f}, v::@NamedTuple{x::Float32, y::Float32, z::Float32, t::Float32}) = edm4hep!Vector4f(v.x, v.y, v.z, v.t)

"""
edm4hep!Vector2i
# Fields
- `a::Int32`: 
- `b::Int32`: 
"""
struct edm4hep!Vector2i <: POD
    a::Int32                         
    b::Int32                         
    edm4hep!Vector2i(a=0, b=0) = new(a, b)
end

Base.convert(::Type{edm4hep!Vector2i}, t::Tuple) = edm4hep!Vector2i(t...)
Base.convert(::Type{edm4hep!Vector2i}, v::@NamedTuple{a::Int32, b::Int32}) = edm4hep!Vector2i(v.a, v.b)

"""
edm4hep!Vector3f
# Fields
- `x::Float32`: 
- `y::Float32`: 
- `z::Float32`: 
"""
struct edm4hep!Vector3f <: POD
    x::Float32                       
    y::Float32                       
    z::Float32                       
    edm4hep!Vector3f(x=0, y=0, z=0) = new(x, y, z)
end

Base.convert(::Type{edm4hep!Vector3f}, t::Tuple) = edm4hep!Vector3f(t...)
Base.convert(::Type{edm4hep!Vector3f}, v::@NamedTuple{x::Float32, y::Float32, z::Float32}) = edm4hep!Vector3f(v.x, v.y, v.z)

"""
edm4hep!Vector3d
# Fields
- `x::Float64`: 
- `y::Float64`: 
- `z::Float64`: 
"""
struct edm4hep!Vector3d <: POD
    x::Float64                       
    y::Float64                       
    z::Float64                       
    edm4hep!Vector3d(x=0, y=0, z=0) = new(x, y, z)
end

Base.convert(::Type{edm4hep!Vector3d}, t::Tuple) = edm4hep!Vector3d(t...)
Base.convert(::Type{edm4hep!Vector3d}, v::@NamedTuple{x::Float64, y::Float64, z::Float64}) = edm4hep!Vector3d(v.x, v.y, v.z)

"""
edm4eic!Cov4f
# Fields
- `xx::Float32`: 
- `yy::Float32`: 
- `zz::Float32`: 
- `tt::Float32`: 
- `xy::Float32`: 
- `xz::Float32`: 
- `xt::Float32`: 
- `yz::Float32`: 
- `yt::Float32`: 
- `zt::Float32`: 
"""
struct edm4eic!Cov4f <: POD
    xx::Float32                      
    yy::Float32                      
    zz::Float32                      
    tt::Float32                      
    xy::Float32                      
    xz::Float32                      
    xt::Float32                      
    yz::Float32                      
    yt::Float32                      
    zt::Float32                      
    edm4eic!Cov4f(xx=0, yy=0, zz=0, tt=0, xy=0, xz=0, xt=0, yz=0, yt=0, zt=0) = new(xx, yy, zz, tt, xy, xz, xt, yz, yt, zt)
end

Base.convert(::Type{edm4eic!Cov4f}, t::Tuple) = edm4eic!Cov4f(t...)
Base.convert(::Type{edm4eic!Cov4f}, v::@NamedTuple{xx::Float32, yy::Float32, zz::Float32, tt::Float32, xy::Float32, xz::Float32, xt::Float32, yz::Float32, yt::Float32, zt::Float32}) = edm4eic!Cov4f(v.xx, v.yy, v.zz, v.tt, v.xy, v.xz, v.xt, v.yz, v.yt, v.zt)

"""
edm4eic!Cov6f
# Fields
- `covariance::SVector{21,Float32}`: 6d triangular packed covariance matrix
"""
struct edm4eic!Cov6f <: POD
    covariance::SVector{21,Float32}  # 6d triangular packed covariance matrix
    edm4eic!Cov6f(covariance=0) = new(covariance)
end

Base.convert(::Type{edm4eic!Cov6f}, t::Tuple) = edm4eic!Cov6f(t...)
Base.convert(::Type{edm4eic!Cov6f}, v::@NamedTuple{covariance::SVector{21,Float32}}) = edm4eic!Cov6f(v.covariance)

"""
edm4eic!Cov2f
# Fields
- `xx::Float32`: 
- `yy::Float32`: 
- `xy::Float32`: 
"""
struct edm4eic!Cov2f <: POD
    xx::Float32                      
    yy::Float32                      
    xy::Float32                      
    edm4eic!Cov2f(xx=0, yy=0, xy=0) = new(xx, yy, xy)
end

Base.convert(::Type{edm4eic!Cov2f}, t::Tuple) = edm4eic!Cov2f(t...)
Base.convert(::Type{edm4eic!Cov2f}, v::@NamedTuple{xx::Float32, yy::Float32, xy::Float32}) = edm4eic!Cov2f(v.xx, v.yy, v.xy)

"""
edm4hep!HitLevelData
# Fields
- `cellID::UInt64`: cell id
- `N::UInt32`: number of reconstructed ionization cluster.
- `eDep::Float32`: reconstructed energy deposit [GeV].
- `pathLength::Float32`: track path length [mm].
"""
struct edm4hep!HitLevelData <: POD
    cellID::UInt64                   # cell id
    N::UInt32                        # number of reconstructed ionization cluster.
    eDep::Float32                    # reconstructed energy deposit [GeV].
    pathLength::Float32              # track path length [mm].
    edm4hep!HitLevelData(cellID=0, N=0, eDep=0, pathLength=0) = new(cellID, N, eDep, pathLength)
end

Base.convert(::Type{edm4hep!HitLevelData}, t::Tuple) = edm4hep!HitLevelData(t...)
Base.convert(::Type{edm4hep!HitLevelData}, v::@NamedTuple{cellID::UInt64, N::UInt32, eDep::Float32, pathLength::Float32}) = edm4hep!HitLevelData(v.cellID, v.N, v.eDep, v.pathLength)

"""
edm4hep!Hypothesis
# Fields
- `chi2::Float32`: chi2
- `expected::Float32`: expected value
- `sigma::Float32`: sigma value
"""
struct edm4hep!Hypothesis <: POD
    chi2::Float32                    # chi2
    expected::Float32                # expected value
    sigma::Float32                   # sigma value
    edm4hep!Hypothesis(chi2=0, expected=0, sigma=0) = new(chi2, expected, sigma)
end

Base.convert(::Type{edm4hep!Hypothesis}, t::Tuple) = edm4hep!Hypothesis(t...)
Base.convert(::Type{edm4hep!Hypothesis}, v::@NamedTuple{chi2::Float32, expected::Float32, sigma::Float32}) = edm4hep!Hypothesis(v.chi2, v.expected, v.sigma)

"""
edm4hep!TrackState
# Fields
- `location::Int32`: for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation
- `D0::Float32`: transverse impact parameter
- `phi::Float32`: azimuthal angle
- `omega::Float32`: is the signed curvature of the track in [1/mm].
- `Z0::Float32`: longitudinal impact parameter
- `tanLambda::Float32`: lambda is the dip angle of the track in r-z
- `time::Float32`: time of the track at this trackstate
- `referencePoint::edm4hep!Vector3f`: Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter. [mm]
- `covMatrix::SVector{21,Float32}`: lower triangular covariance matrix of the track parameters.  the order of parameters is  d0, phi, omega, z0, tan(lambda), time. the array is a row-major flattening of the matrix.
"""
struct edm4hep!TrackState <: POD
    location::Int32                  # for use with At{Other|IP|FirstHit|LastHit|Calorimeter|Vertex}|LastLocation
    D0::Float32                      # transverse impact parameter
    phi::Float32                     # azimuthal angle
    omega::Float32                   # is the signed curvature of the track in [1/mm].
    Z0::Float32                      # longitudinal impact parameter
    tanLambda::Float32               # lambda is the dip angle of the track in r-z
    time::Float32                    # time of the track at this trackstate
    referencePoint::edm4hep!Vector3f # Reference point of the track parameters, e.g. the origin at the IP, or the position  of the first/last hits or the entry point into the calorimeter. [mm]
    covMatrix::SVector{21,Float32}   # lower triangular covariance matrix of the track parameters.  the order of parameters is  d0, phi, omega, z0, tan(lambda), time. the array is a row-major flattening of the matrix.
    edm4hep!TrackState(location=0, D0=0, phi=0, omega=0, Z0=0, tanLambda=0, time=0, referencePoint=0, covMatrix=0) = new(location, D0, phi, omega, Z0, tanLambda, time, referencePoint, covMatrix)
end

Base.convert(::Type{edm4hep!TrackState}, t::Tuple) = edm4hep!TrackState(t...)
Base.convert(::Type{edm4hep!TrackState}, v::@NamedTuple{location::Int32, D0::Float32, phi::Float32, omega::Float32, Z0::Float32, tanLambda::Float32, time::Float32, referencePoint::edm4hep!Vector3f, covMatrix::SVector{21,Float32}}) = edm4hep!TrackState(v.location, v.D0, v.phi, v.omega, v.Z0, v.tanLambda, v.time, v.referencePoint, v.covMatrix)

"""
edm4eic!Cov3f
# Fields
- `xx::Float32`: 
- `yy::Float32`: 
- `zz::Float32`: 
- `xy::Float32`: 
- `xz::Float32`: 
- `yz::Float32`: 
"""
struct edm4eic!Cov3f <: POD
    xx::Float32                      
    yy::Float32                      
    zz::Float32                      
    xy::Float32                      
    xz::Float32                      
    yz::Float32                      
    edm4eic!Cov3f(xx=0, yy=0, zz=0, xy=0, xz=0, yz=0) = new(xx, yy, zz, xy, xz, yz)
end

Base.convert(::Type{edm4eic!Cov3f}, t::Tuple) = edm4eic!Cov3f(t...)
Base.convert(::Type{edm4eic!Cov3f}, v::@NamedTuple{xx::Float32, yy::Float32, zz::Float32, xy::Float32, xz::Float32, yz::Float32}) = edm4eic!Cov3f(v.xx, v.yy, v.zz, v.xy, v.xz, v.yz)

"""
edm4eic!TrackPoint
# Fields
- `surface::UInt64`: Surface track was propagated to (possibly multiple per detector)
- `system::UInt32`: Detector system track was propagated to
- `position::edm4hep!Vector3f`: Position of the trajectory point [mm]
- `positionError::edm4eic!Cov3f`: Error on the position
- `momentum::edm4hep!Vector3f`: 3-momentum at the point [GeV]
- `momentumError::edm4eic!Cov3f`: Error on the 3-momentum
- `time::Float32`: Time at this point [ns]
- `timeError::Float32`: Error on the time at this point
- `theta::Float32`: polar direction of the track at the surface [rad]
- `phi::Float32`: azimuthal direction of the track at the surface [rad]
- `directionError::edm4eic!Cov2f`: Error on the polar and azimuthal angles
- `pathlength::Float32`: Pathlength from the origin to this point
- `pathlengthError::Float32`: Error on the pathlength
"""
struct edm4eic!TrackPoint <: POD
    surface::UInt64                  # Surface track was propagated to (possibly multiple per detector)
    system::UInt32                   # Detector system track was propagated to
    position::edm4hep!Vector3f       # Position of the trajectory point [mm]
    positionError::edm4eic!Cov3f     # Error on the position
    momentum::edm4hep!Vector3f       # 3-momentum at the point [GeV]
    momentumError::edm4eic!Cov3f     # Error on the 3-momentum
    time::Float32                    # Time at this point [ns]
    timeError::Float32               # Error on the time at this point
    theta::Float32                   # polar direction of the track at the surface [rad]
    phi::Float32                     # azimuthal direction of the track at the surface [rad]
    directionError::edm4eic!Cov2f    # Error on the polar and azimuthal angles
    pathlength::Float32              # Pathlength from the origin to this point
    pathlengthError::Float32         # Error on the pathlength
    edm4eic!TrackPoint(surface=0, system=0, position=0, positionError=0, momentum=0, momentumError=0, time=0, timeError=0, theta=0, phi=0, directionError=0, pathlength=0, pathlengthError=0) = new(surface, system, position, positionError, momentum, momentumError, time, timeError, theta, phi, directionError, pathlength, pathlengthError)
end

Base.convert(::Type{edm4eic!TrackPoint}, t::Tuple) = edm4eic!TrackPoint(t...)
Base.convert(::Type{edm4eic!TrackPoint}, v::@NamedTuple{surface::UInt64, system::UInt32, position::edm4hep!Vector3f, positionError::edm4eic!Cov3f, momentum::edm4hep!Vector3f, momentumError::edm4eic!Cov3f, time::Float32, timeError::Float32, theta::Float32, phi::Float32, directionError::edm4eic!Cov2f, pathlength::Float32, pathlengthError::Float32}) = edm4eic!TrackPoint(v.surface, v.system, v.position, v.positionError, v.momentum, v.momentumError, v.time, v.timeError, v.theta, v.phi, v.directionError, v.pathlength, v.pathlengthError)

"""
edm4hep!Quantity
# Fields
- `type::Int16`: flag identifying how to interpret the quantity
- `value::Float32`: value of the quantity
- `error::Float32`: error on the value of the quantity
"""
struct edm4hep!Quantity <: POD
    type::Int16                      # flag identifying how to interpret the quantity
    value::Float32                   # value of the quantity
    error::Float32                   # error on the value of the quantity
    edm4hep!Quantity(type=0, value=0, error=0) = new(type, value, error)
end

Base.convert(::Type{edm4hep!Quantity}, t::Tuple) = edm4hep!Quantity(t...)
Base.convert(::Type{edm4hep!Quantity}, v::@NamedTuple{type::Int16, value::Float32, error::Float32}) = edm4hep!Quantity(v.type, v.value, v.error)

"""
edm4eic!HGCROCSample
# Fields
- `ADC::UInt16`: [ADC Counts], amplitude of signal during sample, valid IFF TOTInProgress is false
- `timeOfArrival::UInt16`: Time of arrival (TOA) [TDC counts], nonzero IFF ADC crossed threshold upwards during sample
- `timeOverThreshold::UInt16`: Time over threshold (TOT) [TDC counts], nonzero IFF ADC crossed threshold downwards during sample AND if TOA fired in a previous sample
- `TOTInProgress::Bool`: Flag which indicates if TOT calculation is ongoing, ADC value may be corrupted if this is true
- `TOTComplete::Bool`: Flag which indicates if a TOT calculation is complete and TOT value is valid
"""
struct edm4eic!HGCROCSample <: POD
    ADC::UInt16                      # [ADC Counts], amplitude of signal during sample, valid IFF TOTInProgress is false
    timeOfArrival::UInt16            # Time of arrival (TOA) [TDC counts], nonzero IFF ADC crossed threshold upwards during sample
    timeOverThreshold::UInt16        # Time over threshold (TOT) [TDC counts], nonzero IFF ADC crossed threshold downwards during sample AND if TOA fired in a previous sample
    TOTInProgress::Bool              # Flag which indicates if TOT calculation is ongoing, ADC value may be corrupted if this is true
    TOTComplete::Bool                # Flag which indicates if a TOT calculation is complete and TOT value is valid
    edm4eic!HGCROCSample(ADC=0, timeOfArrival=0, timeOverThreshold=0, TOTInProgress=0, TOTComplete=0) = new(ADC, timeOfArrival, timeOverThreshold, TOTInProgress, TOTComplete)
end

Base.convert(::Type{edm4eic!HGCROCSample}, t::Tuple) = edm4eic!HGCROCSample(t...)
Base.convert(::Type{edm4eic!HGCROCSample}, v::@NamedTuple{ADC::UInt16, timeOfArrival::UInt16, timeOverThreshold::UInt16, TOTInProgress::Bool, TOTComplete::Bool}) = edm4eic!HGCROCSample(v.ADC, v.timeOfArrival, v.timeOverThreshold, v.TOTInProgress, v.TOTComplete)

"""
edm4eic!Surface
# Fields
- `surfaceType::Int32`: Cone = 0, Cylinder = 1, Disc = 2, Perigee = 3, Plane = 4, Straw = 5, Curvilinear = 6, Other = 7
- `boundsType::Int32`: eCone = 0, eCylinder = 1, eDiamond = 2, eDisc = 3, eEllipse = 4, eLine = 5, eRectangle = 6, eTrapezoid = 7, eTriangle = 8, eDiscTrapezoid = 9, eConvexPolygon = 10, eAnnulus = 11, eBoundless = 12, eOther = 13
- `geometryId::UInt64`: bit pattern volume:8,boundary:8,layer:12,approach:8,sensitive:20,extra:8
- `identifier::UInt64`: identifier of associated detector element, if available
- `boundValues::SVector{10,Float64}`: bound values, e.g. for RectangleBounds, BoundValues are eMinX = 0, eMinY = 1, eMaxX = 2, eMaxY = 3, eSize = 4
- `boundValuesSize::UInt32`: size of bound values
- `transform::SVector{16,Float64}`: row-wise 4x4 affine transform [R T; 0 1] with 3x3 rotation matrix R and translation column 3-vector T
"""
struct edm4eic!Surface <: POD
    surfaceType::Int32               # Cone = 0, Cylinder = 1, Disc = 2, Perigee = 3, Plane = 4, Straw = 5, Curvilinear = 6, Other = 7
    boundsType::Int32                # eCone = 0, eCylinder = 1, eDiamond = 2, eDisc = 3, eEllipse = 4, eLine = 5, eRectangle = 6, eTrapezoid = 7, eTriangle = 8, eDiscTrapezoid = 9, eConvexPolygon = 10, eAnnulus = 11, eBoundless = 12, eOther = 13
    geometryId::UInt64               # bit pattern volume:8,boundary:8,layer:12,approach:8,sensitive:20,extra:8
    identifier::UInt64               # identifier of associated detector element, if available
    boundValues::SVector{10,Float64} # bound values, e.g. for RectangleBounds, BoundValues are eMinX = 0, eMinY = 1, eMaxX = 2, eMaxY = 3, eSize = 4
    boundValuesSize::UInt32          # size of bound values
    transform::SVector{16,Float64}   # row-wise 4x4 affine transform [R T; 0 1] with 3x3 rotation matrix R and translation column 3-vector T
    edm4eic!Surface(surfaceType=0, boundsType=0, geometryId=0, identifier=0, boundValues=0, boundValuesSize=0, transform=0) = new(surfaceType, boundsType, geometryId, identifier, boundValues, boundValuesSize, transform)
end

Base.convert(::Type{edm4eic!Surface}, t::Tuple) = edm4eic!Surface(t...)
Base.convert(::Type{edm4eic!Surface}, v::@NamedTuple{surfaceType::Int32, boundsType::Int32, geometryId::UInt64, identifier::UInt64, boundValues::SVector{10,Float64}, boundValuesSize::UInt32, transform::SVector{16,Float64}}) = edm4eic!Surface(v.surfaceType, v.boundsType, v.geometryId, v.identifier, v.boundValues, v.boundValuesSize, v.transform)

"""
edm4eic!CherenkovParticleIDHypothesis
# Fields
- `PDG::Int32`: PDG code
- `npe::Float32`: Overall photoelectron count
- `weight::Float32`: Weight of this hypothesis, such as likelihood, moment, etc.
"""
struct edm4eic!CherenkovParticleIDHypothesis <: POD
    PDG::Int32                       # PDG code
    npe::Float32                     # Overall photoelectron count
    weight::Float32                  # Weight of this hypothesis, such as likelihood, moment, etc.
    edm4eic!CherenkovParticleIDHypothesis(PDG=0, npe=0, weight=0) = new(PDG, npe, weight)
end

Base.convert(::Type{edm4eic!CherenkovParticleIDHypothesis}, t::Tuple) = edm4eic!CherenkovParticleIDHypothesis(t...)
Base.convert(::Type{edm4eic!CherenkovParticleIDHypothesis}, v::@NamedTuple{PDG::Int32, npe::Float32, weight::Float32}) = edm4eic!CherenkovParticleIDHypothesis(v.PDG, v.npe, v.weight)

"""
edm4eic!CovDiag3f
# Fields
- `xx::Float32`: 
- `yy::Float32`: 
- `zz::Float32`: 
"""
struct edm4eic!CovDiag3f <: POD
    xx::Float32                      
    yy::Float32                      
    zz::Float32                      
    edm4eic!CovDiag3f(xx=0, yy=0, zz=0) = new(xx, yy, zz)
end

Base.convert(::Type{edm4eic!CovDiag3f}, t::Tuple) = edm4eic!CovDiag3f(t...)
Base.convert(::Type{edm4eic!CovDiag3f}, v::@NamedTuple{xx::Float32, yy::Float32, zz::Float32}) = edm4eic!CovDiag3f(v.xx, v.yy, v.zz)

const CovDiag3f = edm4eic!CovDiag3f
const CherenkovParticleIDHypothesis = edm4eic!CherenkovParticleIDHypothesis
const Surface = edm4eic!Surface
const HGCROCSample = edm4eic!HGCROCSample
const Quantity = edm4hep!Quantity
const Cov3f = edm4eic!Cov3f
const TrackState = edm4hep!TrackState
const Hypothesis = edm4hep!Hypothesis
const HitLevelData = edm4hep!HitLevelData
const Cov2f = edm4eic!Cov2f
const Cov6f = edm4eic!Cov6f
const Cov4f = edm4eic!Cov4f
const Vector3d = edm4hep!Vector3d
const Vector3f = edm4hep!Vector3f
const Vector2i = edm4hep!Vector2i
const Vector4f = edm4hep!Vector4f
const Vector2f = edm4hep!Vector2f
const TrackPoint = edm4eic!TrackPoint
export CovDiag3f, CherenkovParticleIDHypothesis, Surface, HGCROCSample, Quantity, Cov3f, TrackState, Hypothesis, HitLevelData, Cov2f, Cov6f, Cov4f, Vector3d, Vector3f, Vector2i, Vector4f, Vector2f, TrackPoint
